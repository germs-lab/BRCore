#' Identify Core Microbial Taxa
#'
#' @description
#' This function identifies core microbial taxa based on abundance-occupancy 
#' distributions and their contributions to Bray-Curtis dissimilarity. Core taxa 
#' are selected using either the "increase" or "elbow" method. This fucntion 
#' implements the method developed by Shade and Stopnisek (2019) Curr Opin 
#' Microbiol, see below for details.
#'
#' @param physeq_obj A \code{phyloseq} object with \code{otu_table} and
#'   \code{sample_data}.
#' @param priority_var Bare column name \emph{or} a string naming a column in
#'   \code{sample_data(physeq_obj)} (e.g., \code{sampling_date}, \code{"Site"}).
#'   This variable defines the groups in which per-group presence frequency is
#'   calculated.
#' @param increase_value Numeric scalar (default \code{0.02}) used for the
#'   BC-increase threshold. The cut is taken at the last rank where
#'   \code{IncreaseBC >= 1 + increase_value}.
#' @param seed Optional integer to set the RNG seed for reproducibility.
#'
#' @return A list with:
#' \itemize{
#'   \item \code{bray_curtis_ranked} tibble with \code{rank}, mean BC across
#'         sample pairs at each cumulative rank, normalized proportion, the
#'         multiplicative \code{IncreaseBC}, and the elbow helper metric.
#'   \item \code{otu_ranked} tibble with \code{otu} and composite \code{rank}.
#'   \item \code{occupancy_abundance} tibble with \code{otu}, occupancy
#'         (\code{otu_occ}) and mean relative abundance (\code{otu_rel}).
#'   \item \code{elbow} core set identified by elbow method (integer).
#'   \item \code{bc_increase} core set identified by last % BC-increase (integer).
#'   \item \code{increase_value} % increase value used in the calculation.
#'   \item \code{elbow_core} core OTU/ASVs using elbow method (character vector).
#'   \item \code{increase_core} core OTU/ASVs using last % BC-increase method (character vector).
#'   \item \code{otu_table} otu_table counts (otu x samples) used (data.frame).
#'   \item \code{sample_metadata} samples metadata (data.frame).
#'   \item \code{taxonomy_table} taxonomy if present (data.frame); otherwise NULL.
#' }
#'
#' @details
#' The function ranks taxa by a composite index (occupancy + "core within group" 
#' frequency) computed per level of a user-specified sample metadata variable (e.g., 
#' sampling_date,  genotype, site). Then, it simulates Bray-Curtis (BC) accumulation across
#' samples while iteratively adding taxa in rank order to find (1) an "elbow"
#' cut and (2) a multiplicative BC-increase threshold cut to prioritize the core set.
#' 
#' @references Ashley Shade and Nejc Stopnisek (2019) Abundance-occupancy 
#' distributions to prioritize plant core microbiome membership. Current 
#' Opinion in Microbiology, 49:50-58 DOI:https://doi.org/10.1016/j.mib.2019.09.008
#'
#' @section Dependencies:
#' Requires \pkg{phyloseq}, \pkg{dplyr}, \pkg{tidyr}, \pkg{tibble}, \pkg{rlang},
#' and \pkg{vegan}.
#'
#' @importFrom phyloseq sample_sums taxa_are_rows otu_table sample_data
#' @importFrom dplyr left_join group_by summarise transmute arrange desc mutate n last
#' @importFrom tidyr pivot_longer gather
#' @importFrom tibble rownames_to_column column_to_rownames
#' @importFrom rlang ensym as_name .data
#' @importFrom vegan decostand
#' @importFrom magrittr %>%
#'
#' @examplesIf requireNamespace("phyloseq", quietly = TRUE)
#' \donttest{
#'   # Example using your switchgrass phyloseq object and grouping variable 'sampling_date'
#'   data("switchgrass", package = "BRCore")
#'
#'   res <- identify_core(
#'     physeq_obj     = switchgrass,
#'     priority_var   = "sampling_date",
#'     increase_value = 0.02,
#'     seed           = 091825
#'   )
#'
#'   # Inspect results
#'   str(res)
#' }
#' 
#' @export
identify_core <- function(physeq_obj,
                          priority_var,
                          increase_value = 0.02,
                          seed = NULL) {
    
    # ------------------------- check seed -------------------------
    cli::cli_text("\nSeed used: {seed}\n")
    
    if (is.null(seed)) {
        cli::cli_warn("No seed was set. Results may not be reproducible.")
    } else {
        set.seed(seed)
    }
    
    # ------------------------- input checks -------------------------
    # Error handling: type check
    if (!inherits(physeq_obj, "phyloseq")) {
        cli::cli_abort(
            "{.arg physeq_obj} must be a 'phyloseq' object.\nYou've supplied a {class(physeq_obj)[1]} vector."
        )
    }
    # If the check passes, continue processing
    cli::cli_alert_success("Input phyloseq object is valid!")
    
    # ------------------------- define arguments -------------------------
    
    if (min(phyloseq::sample_sums(physeq_obj)) == max(phyloseq::sample_sums(physeq_obj))) {
        nReads <- min(phyloseq::sample_sums(physeq_obj))
        cli::cli_alert_info("otu_table() is rarefied at a depth of: {nReads}")
    } else {
        stop("The otu_table() is not rarefied!")
    }
    
    otu <- phyloseq::otu_table(physeq_obj, taxa_are_rows = TRUE) %>% as("matrix")
    map <- phyloseq::sample_data(physeq_obj) %>% as("data.frame")
    map$sample_id <- rownames(map)
    
    ### check for a tax_table if present, if not just print a warning and continue.
    taxa <- NULL
    tx <- tryCatch(phyloseq::tax_table(physeq_obj), error = function(e) NULL)
    
    if (!is.null(tx)) {
        txm <- tryCatch(as(tx, "matrix"), error = function(e) NULL)
        if (!is.null(txm) && is.matrix(txm) && ncol(txm) > 0L) {
            taxa <- as.data.frame(txm, stringsAsFactors = FALSE)
        }
    }
    
    # (optional) message so users know what's happening
    if (is.null(taxa)) {
        cli::cli_alert_info("No taxonomy found (or empty). Continuing without taxonomy.")
    }
    
    # ---------------------- core prioritizing variable -------------------------
    data_var <- priority_var
    cli::cli_alert_success("Core prioritizing variable: {data_var}")
    
    # ---------------------- abundance occupancy -------------------------
    # occupancy and mean rel. abundance
    otu_PA  <- 1 * (otu > 0)
    otu_occ <- rowSums(otu_PA) / ncol(otu_PA)
    otu_rel <- apply(vegan::decostand(otu, method = "total", MARGIN = 2), 1, mean)
    
    occ_abun <- data.frame(otu_occ = otu_occ, otu_rel = otu_rel) %>%
        tibble::rownames_to_column("otu")
    
    # presence summary by grouping variable
    PresenceSum <- data.frame(otu = base::as.factor(rownames(otu)), otu, check.names = FALSE) %>%
        tidyr::pivot_longer(
            cols = -otu, names_to = "sample_id", values_to = "abun"
        ) %>%
        dplyr::left_join(map, by = "sample_id") %>%
        dplyr::group_by(.data$otu, .data[[data_var]]) %>%
        dplyr::summarise(
            time_freq = sum(.data$abun > 0) / dplyr::n(), # frequency within each group
            coreTime  = as.integer(time_freq == 1),
            .groups   = "drop"
        ) %>%
        dplyr::group_by(.data$otu) %>%
        dplyr::summarise(
            sumF  = sum(.data$time_freq),
            sumG  = sum(.data$coreTime),
            nS    = dplyr::n(),                         # number of groups/levels
            Index = (sumF + sumG) / nS,
            .groups = "drop"
        )
    
    otu_ranked <- occ_abun %>%
        dplyr::left_join(PresenceSum, by = "otu") %>%
        dplyr::transmute(otu, rank = .data$Index) %>%
        dplyr::arrange(dplyr::desc(.data$rank))
    
    # ------------------------- BC accumulation -------------------------
    # cumulative BC across samples while adding taxa in rank order
    # pairwise BC on *current* subset of taxa, normalized by nReads, matching your formula
    sample_pairs <- utils::combn(ncol(otu), 2)
    pair_labels <- apply(sample_pairs, 2, function(ix)
        paste(colnames(otu)[ix], collapse = " - ")
    )
    
    # start with the first ranked OTU
    start_idx <- match(otu_ranked$otu[1], rownames(otu))
    start_matrix <- matrix(otu[start_idx, ], nrow = 1,
                           dimnames = list(otu_ranked$otu[1], colnames(otu)))
    
    bc_vec <- apply(sample_pairs, 2, function(ix) {
        sum(abs(start_matrix[, ix[1]] - start_matrix[, ix[2]])) / (2 * nReads)
    })
    
    BCaddition <- data.frame(x_names = pair_labels, `1` = bc_vec, check.names = FALSE)
    
    if (nrow(otu_ranked) > 1) {
        for (i in 2:nrow(otu_ranked)) {
            add_idx <- match(otu_ranked$otu[i], rownames(otu))
            add_matrix <- matrix(otu[add_idx, ], nrow = 1,
                                 dimnames = list(otu_ranked$otu[i], colnames(otu)))
            start_matrix <- rbind(start_matrix, add_matrix)
            
            bc_vec <- apply(sample_pairs, 2, function(ix) {
                sum(abs(start_matrix[, ix[1]] - start_matrix[, ix[2]])) / (2 * nReads)
            })
            BCaddition <- dplyr::left_join(
                BCaddition,
                data.frame(x_names = pair_labels, value = bc_vec, check.names = FALSE),
                by = "x_names"
            )
            names(BCaddition)[ncol(BCaddition)] <- as.character(i)
        }
    }
    
    temp_BC_matrix <- BCaddition %>%
        tibble::column_to_rownames("x_names") %>%
        as.matrix()
    
    BC_ranked <- data.frame(
        rank = base::as.factor(rownames(t(temp_BC_matrix))),
        t(temp_BC_matrix),
        check.names = FALSE
    ) %>%
        tidyr::pivot_longer(
            -rank, names_to = "comparison", values_to = "BC"
        ) %>%
        dplyr::group_by(.data$rank) %>%
        dplyr::summarise(MeanBC = mean(.data$BC), .groups = "drop") %>%
        dplyr::arrange(MeanBC) %>%
        dplyr::mutate(proportionBC = .data$MeanBC / max(.data$MeanBC))
    
    # multiplicative increase between successive ranks
    if (nrow(BC_ranked) >= 2) {
        Increase <- BC_ranked$MeanBC[-1] / BC_ranked$MeanBC[-nrow(BC_ranked)]
        increaseDF <- data.frame(IncreaseBC = c(0, Increase),
                                 rank = factor(seq_len(length(Increase) + 1)))
    } else {
        increaseDF <- data.frame(IncreaseBC = 0, rank = factor(1))
    }
    BC_ranked <- dplyr::left_join(BC_ranked, increaseDF, by = "rank")
    
    # elbow by forward-backward slope difference
    fo_difference <- function(pos) {
        left  <- (BC_ranked$MeanBC[pos] - BC_ranked$MeanBC[1]) / pos
        right <- (BC_ranked$MeanBC[nrow(BC_ranked)] - BC_ranked$MeanBC[pos]) /
            max(1, (nrow(BC_ranked) - pos))
        left - right
    }
    BC_ranked$fo_diffs <- vapply(seq_len(nrow(BC_ranked)), fo_difference, numeric(1))
    elbow <- which.max(BC_ranked$fo_diffs)
    
    # threshold cut based on multiplicative increase
    thr <- 1 + increase_value
    valid_increases <- which(BC_ranked$IncreaseBC >= thr)
    lastCall <- if (length(valid_increases)) utils::tail(valid_increases, 1) else 1
    
    # ------------------------- select cores -------------------------
    elbow_core <- otu_ranked %>%
        tibble::rownames_to_column("otu_order") %>%
        dplyr::mutate(otu_order = as.numeric(.data$otu_order)) %>%
        dplyr::filter(.data$otu_order <= elbow) %>%
        dplyr::pull(.data$otu)
    
    increase_core <- otu_ranked %>%
        tibble::rownames_to_column("otu_order") %>%
        dplyr::mutate(otu_order = as.numeric(.data$otu_order)) %>%
        dplyr::filter(.data$otu_order <= lastCall) %>%
        dplyr::pull(.data$otu)
    
    # ------------------------- return -------------------------
    out <- list(
        bray_curtis_ranked  = BC_ranked,
        otu_ranked          = otu_ranked,
        occupancy_abundance = occ_abun,
        elbow               = as.integer(elbow),
        bc_increase         = as.integer(lastCall),
        increase_value      = increase_value,
        elbow_core          = elbow_core,
        increase_core       = increase_core,
        otu_table           = otu,
        metadata            = map,
        taxonomy            = taxa
    )
    class(out) <- c("identify_core_result", class(out))
    out
}
